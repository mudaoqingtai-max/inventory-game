<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Battle Inventory</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: white;
            font-family: 'Verdana', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            touch-action: none;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- ãƒ˜ãƒƒãƒ€ãƒ¼ & ãƒãƒˆãƒ«ç”»é¢ --- */
        #battle-area {
            width: 100%;
            height: 25vh;
            background: #2c3e50;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            border-bottom: 4px solid #000;
            position: relative;
        }

        .status-box {
            text-align: center;
            width: 35%;
        }
        
        .hp-bar {
            width: 100%;
            height: 12px;
            background: #555;
            border: 2px solid #000;
            margin-top: 5px;
            border-radius: 6px;
            overflow: hidden;
        }
        .hp-fill {
            height: 100%;
            background: #2ecc71;
            width: 100%;
            transition: width 0.3s;
        }
        .enemy-hp { background: #e74c3c; }

        #enemy-sprite {
            font-size: 50px;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
            transition: transform 0.1s;
        }

        /* ãƒ€ãƒ¡ãƒ¼ã‚¸è¡¨ç¤ºç”¨ */
        .damage-popup {
            position: absolute;
            color: #ffeb3b;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            animation: floatUp 0.8s forwards;
            text-shadow: 2px 2px 0 #000;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }

        /* --- ã‚°ãƒªãƒƒãƒ‰ï¼ˆã‚«ãƒãƒ³ï¼‰ --- */
        #grid-wrapper {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 2px;
            background-color: #5d4037;
            padding: 6px;
            border: 4px solid #8d6e63;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .cell {
            width: 42px; /* ã‚¹ãƒãƒ›ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´ */
            height: 42px;
            background-color: #3e2723;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }

        .cell.filled { box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .cell.highlight { background-color: rgba(46, 204, 113, 0.6); }
        .cell.invalid { background-color: rgba(231, 76, 60, 0.6); }

        /* --- ã‚¢ã‚¤ãƒ†ãƒ ç½®ãå ´ --- */
        #spawner {
            height: 18vh;
            width: 100%;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            background: #222;
            border-top: 2px solid #444;
        }

        .item-preview {
            display: grid;
            gap: 1px;
            touch-action: none;
            transform-origin: center;
            transition: transform 0.1s, opacity 0.2s;
        }
        
        .item-cell {
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: white;
            border-radius: 2px;
            box-shadow: inset 0 0 2px rgba(255,255,255,0.2);
        }

        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ */
        .dragging {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.9;
            transform: scale(1.2); /* å°‘ã—å¤§ãã */
            filter: drop-shadow(0 10px 10px rgba(0,0,0,0.5));
        }

        /* --- ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆãƒ»çµæœï¼‰ --- */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            text-align: center;
        }
        #overlay h1 { color: #f1c40f; margin-bottom: 10px; font-size: 28px; }
        #overlay p { margin: 20px; color: #ddd; line-height: 1.6; }
        button {
            padding: 15px 40px;
            font-size: 20px;
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 0 #d35400;
            transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: none; }
        
        #sound-toggle {
            position: absolute;
            top: 10px; right: 10px;
            background: #444;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="sound-toggle" onclick="toggleSound()">ğŸ”‡ Sound OFF</div>

    <div id="battle-area">
        <div class="status-box">
            <div id="player-name">å‹‡è€…</div>
            <div class="hp-bar"><div id="player-hp-bar" class="hp-fill"></div></div>
            <div id="player-hp-text">100/100</div>
        </div>
        
        <div id="enemy-sprite">ğŸ‘¾</div>

        <div class="status-box">
            <div id="enemy-name">ã‚¹ãƒ©ã‚¤ãƒ </div>
            <div class="hp-bar"><div id="enemy-hp-bar" class="hp-fill enemy-hp"></div></div>
            <div id="enemy-hp-text">50/50</div>
        </div>
    </div>

    <div id="grid-wrapper">
        <div id="grid-container"></div>
    </div>

    <div id="spawner"></div>

    <div id="overlay">
        <h1 id="msg-title">Battle Inventory</h1>
        <p id="msg-text">
            ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¸¦ã¹ã¦æˆ¦ãŠã†ï¼<br>
            æ¨ªã‹ç¸¦ã«æƒãˆã‚‹ã¨æ”»æ’ƒï¼<br>
            â¤ï¸ã‚’æ¶ˆã™ã¨å›å¾©ï¼
        </p>
        <button onclick="startGame()">Battle Start</button>
    </div>

<script>
    /* =========================================
       1. ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¨ãƒ³ã‚¸ãƒ³ (Web Audio API)
       ========================================= */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let isSoundOn = false;

    function toggleSound() {
        isSoundOn = !isSoundOn;
        document.getElementById('sound-toggle').textContent = isSoundOn ? "ğŸ”Š Sound ON" : "ğŸ”‡ Sound OFF";
        if(isSoundOn && audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playTone(type, freq, duration, vol = 0.1) {
        if (!isSoundOn) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    const SFX = {
        grab: () => playTone('sine', 400, 0.1),
        drop: () => playTone('square', 200, 0.1),
        error: () => playTone('sawtooth', 100, 0.2),
        attack: () => {
            playTone('square', 150, 0.1);
            setTimeout(() => playTone('square', 100, 0.2), 100);
        },
        heal: () => {
            playTone('sine', 600, 0.2);
            setTimeout(() => playTone('sine', 800, 0.4), 100);
        },
        win: () => {
            [440, 554, 659, 880].forEach((f, i) => setTimeout(() => playTone('triangle', f, 0.3), i*100));
        },
        lose: () => {
            [300, 250, 200, 150].forEach((f, i) => setTimeout(() => playTone('sawtooth', f, 0.4), i*150));
        }
    };

    /* =========================================
       2. ã‚²ãƒ¼ãƒ è¨­å®š & ãƒ‡ãƒ¼ã‚¿
       ========================================= */
    const COLS = 6;
    const ROWS = 6; // ã‚¹ãƒãƒ›ã§è¦‹ã‚„ã™ã„ã‚ˆã†ã«æ­£æ–¹å½¢ã«
    
    // ã‚¢ã‚¤ãƒ†ãƒ : ã‚·ãƒ³ãƒ—ãƒ«ã«3ç¨®é¡ã ã‘ï¼ˆé€šå¸¸ã€å›å¾©ã€ãƒ¬ã‚¢æ”»æ’ƒï¼‰
    // type: 0=é€šå¸¸(èŒ¶), 1=å›å¾©(èµ¤/ãƒãƒ¼ãƒˆ), 2=å¼·æ”»æ’ƒ(é‡‘)
    const SHAPES = [
        [[1]], [[1,1]], [[1],[1]], // 1ãƒã‚¹, 2ãƒã‚¹
        [[1,1],[1,1]], // 2x2
        [[1,1,1]], [[1],[1],[1]], // 3ãƒã‚¹
        [[1,0],[1,1]], [[0,1],[1,1]], // Lå­—
        [[1,1,0],[0,1,1]], // Så­—
        [[0,1,0],[1,1,1]] // å‡¸
    ];

    const COLORS = [
        { color: '#8d6e63', icon: 'ğŸ“¦', type: 'atk' }, // èŒ¶è‰²ï¼šé€šå¸¸
        { color: '#e74c3c', icon: 'â¤ï¸', type: 'heal' }, // èµ¤ï¼šå›å¾©
        { color: '#f1c40f', icon: 'âš”ï¸', type: 'crit' }  // é‡‘ï¼šå¼·æ”»æ’ƒ
    ];

    const ENEMIES = [
        { name: "ã‚¹ãƒ©ã‚¤ãƒ ", hp: 50, atk: 5, icon: "ğŸ’§" },
        { name: "ã‚³ã‚¦ãƒ¢ãƒª", hp: 80, atk: 8, icon: "ğŸ¦‡" },
        { name: "ã‚¹ã‚±ãƒ«ãƒˆãƒ³", hp: 120, atk: 12, icon: "ğŸ’€" },
        { name: "ãƒ‰ãƒ©ã‚´ãƒ³", hp: 300, atk: 20, icon: "ğŸ²" }
    ];

    let grid = [];
    let currentEnemyIdx = 0;
    let playerHP = 100;
    let enemyHP = 50;
    const maxHP = 100;
    let isGameOver = false;

    // DOM
    const gridEl = document.getElementById('grid-container');
    const spawnerEl = document.getElementById('spawner');
    const overlay = document.getElementById('overlay');

    /* =========================================
       3. ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
       ========================================= */
    function startGame() {
        overlay.style.display = 'none';
        if(isSoundOn && audioCtx.state === 'suspended') audioCtx.resume();
        initGame();
    }

    function initGame() {
        grid = Array(ROWS).fill().map(() => Array(COLS).fill(null));
        currentEnemyIdx = 0;
        playerHP = 100;
        isGameOver = false;
        loadEnemy(0);
        updateUI();
        renderGrid();
        spawnerEl.innerHTML = '';
        spawnItem(); spawnItem(); spawnItem();
    }

    function loadEnemy(idx) {
        if(idx >= ENEMIES.length) {
            gameEnd(true);
            return;
        }
        const data = ENEMIES[idx];
        enemyHP = data.hp;
        document.getElementById('enemy-name').textContent = data.name;
        document.getElementById('enemy-sprite').textContent = data.icon;
        updateUI();
    }

    function spawnItem() {
        if (spawnerEl.children.length >= 3) return;

        // ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ
        const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        // 20%ã§å›å¾©ã€10%ã§å¼·æ”»æ’ƒã€æ®‹ã‚Šé€šå¸¸
        const r = Math.random();
        let typeIdx = 0;
        if(r < 0.2) typeIdx = 1; 
        else if(r < 0.3) typeIdx = 2;
        
        const style = COLORS[typeIdx];

        const el = document.createElement('div');
        el.className = 'item-preview';
        el.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;
        
        // ãƒ‡ãƒ¼ã‚¿ã‚’æŒãŸã›ã‚‹
        el.dataset.shape = JSON.stringify(shape);
        el.dataset.type = style.type;
        el.dataset.color = style.color;
        el.dataset.icon = style.icon;

        shape.forEach(row => {
            row.forEach(cell => {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'item-cell';
                if (cell) {
                    cellDiv.style.backgroundColor = style.color;
                    cellDiv.textContent = style.icon;
                } else {
                    cellDiv.style.opacity = 0;
                }
                el.appendChild(cellDiv);
            });
        });

        addTouchLogic(el);
        spawnerEl.appendChild(el);
    }

    /* =========================================
       4. ã‚¿ãƒƒãƒï¼†ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ï¼ˆä½ç½®ä¿®æ­£ç‰ˆï¼‰
       ========================================= */
    function addTouchLogic(el) {
        let isDragging = false;
        let clone = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        // è¦–èªæ€§å‘ä¸Šã®ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆæŒ‡ã®ä¸Šã«è¡¨ç¤ºï¼‰
        const VISUAL_OFFSET_Y = 80; 

        const start = (e) => {
            if(isGameOver) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const rect = el.getBoundingClientRect();
            
            // ã‚¿ãƒƒãƒä½ç½®ã¨è¦ç´ ã®ä¸­å¿ƒã®ã‚ºãƒ¬ã‚’è¨ˆç®—
            dragOffsetX = touch.clientX - (rect.left + rect.width / 2);
            dragOffsetY = touch.clientY - (rect.top + rect.height / 2);

            isDragging = true;
            clone = el.cloneNode(true);
            clone.className = 'dragging';
            
            // å…ƒã®ã‚µã‚¤ã‚ºã‚’ç¶­æŒ
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            
            document.body.appendChild(clone);
            move(e);
            
            el.style.opacity = 0.3;
            SFX.grab();
        };

        const move = (e) => {
            if(!isDragging || !clone) return;
            const touch = e.touches ? e.touches[0] : e;
            
            // æŒ‡ã®ä½ç½® - ã‚ºãƒ¬ - è¦–èªæ€§ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            const x = touch.clientX - dragOffsetX;
            const y = touch.clientY - dragOffsetY - VISUAL_OFFSET_Y;

            clone.style.left = (x - clone.offsetWidth / 2) + 'px';
            clone.style.top = (y - clone.offsetHeight / 2) + 'px';

            // ã‚°ãƒªãƒƒãƒ‰åˆ¤å®šã®ãŸã‚ã«ã€Œæœ¬æ¥ã‚ã‚‹ã¹ãå ´æ‰€ï¼ˆæŒ‡ã®ä¸‹ã§ã¯ãªãè¡¨ç¤ºä½ç½®ï¼‰ã€ã‚’æ¸¡ã™
            highlightGrid(x, y, JSON.parse(el.dataset.shape));
        };

        const end = (e) => {
            if(!isDragging) return;
            isDragging = false;
            
            // æœ€å¾Œã®ä½ç½®ã‚’å–å¾—
            const x = parseFloat(clone.style.left) + clone.offsetWidth / 2;
            const y = parseFloat(clone.style.top) + clone.offsetHeight / 2;
            
            const shape = JSON.parse(el.dataset.shape);
            const success = tryPlace(x, y, shape, {
                type: el.dataset.type,
                color: el.dataset.color,
                icon: el.dataset.icon
            });

            if(success) {
                SFX.drop();
                el.remove();
                spawnItem();
                checkLines();
                // æ•µã®æ”»æ’ƒã‚¿ãƒ¼ãƒ³
                enemyTurn();
            } else {
                SFX.error();
                el.style.opacity = 1;
            }

            clone.remove();
            clearHighlight();
        };

        el.addEventListener('mousedown', start);
        el.addEventListener('touchstart', start, {passive: false});
        document.addEventListener('mousemove', move);
        document.addEventListener('touchmove', move, {passive: false});
        document.addEventListener('mouseup', end);
        document.addEventListener('touchend', end);
    }

    // ã‚°ãƒªãƒƒãƒ‰åº§æ¨™è¨ˆç®—
    function getGridPos(x, y) {
        const rect = gridEl.getBoundingClientRect();
        // ç¯„å›²å†…ã‹ç°¡æ˜“ãƒã‚§ãƒƒã‚¯
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return null;

        const cellSize = rect.width / COLS;
        const c = Math.floor((x - rect.left) / cellSize);
        const r = Math.floor((y - rect.top) / cellSize);

        if (c >= 0 && c < COLS && r >= 0 && r < ROWS) return { c, r };
        return null;
    }

    function tryPlace(x, y, shape, data) {
        const pos = getGridPos(x, y);
        if (!pos) return false;

        // é…ç½®ã®ä¸­å¿ƒåº§æ¨™ã‹ã‚‰å·¦ä¸Šã‚’è¨ˆç®—
        const startC = pos.c - Math.floor(shape[0].length / 2);
        const startR = pos.r - Math.floor(shape.length / 2);

        // 1. ã¯ã¿å‡ºã—ï¼†è¡çªãƒã‚§ãƒƒã‚¯
        for(let r=0; r<shape.length; r++) {
            for(let c=0; c<shape[r].length; c++) {
                if(shape[r][c] === 1) {
                    const targetC = startC + c;
                    const targetR = startR + r;
                    if(targetC < 0 || targetC >= COLS || targetR < 0 || targetR >= ROWS || grid[targetR][targetC]) {
                        return false;
                    }
                }
            }
        }

        // 2. é…ç½®ç¢ºå®š
        for(let r=0; r<shape.length; r++) {
            for(let c=0; c<shape[r].length; c++) {
                if(shape[r][c] === 1) {
                    grid[startR + r][startC + c] = { ...data };
                }
            }
        }
        renderGrid();
        return true;
    }

    function highlightGrid(x, y, shape) {
        clearHighlight();
        const pos = getGridPos(x, y);
        if (!pos) return;

        const startC = pos.c - Math.floor(shape[0].length / 2);
        const startR = pos.r - Math.floor(shape.length / 2);
        let isValid = true;
        let targets = [];

        for(let r=0; r<shape.length; r++) {
            for(let c=0; c<shape[r].length; c++) {
                if(shape[r][c] === 1) {
                    const targetC = startC + c;
                    const targetR = startR + r;
                    if(targetC < 0 || targetC >= COLS || targetR < 0 || targetR >= ROWS || grid[targetR][targetC]) {
                        isValid = false;
                    } else {
                        const idx = targetR * COLS + targetC;
                        if(gridEl.children[idx]) targets.push(gridEl.children[idx]);
                    }
                }
            }
        }

        targets.forEach(el => el.classList.add(isValid ? 'highlight' : 'invalid'));
    }

    function clearHighlight() {
        Array.from(document.getElementsByClassName('cell')).forEach(el => {
            el.classList.remove('highlight', 'invalid');
        });
    }

    function renderGrid() {
        gridEl.innerHTML = '';
        grid.forEach(row => {
            row.forEach(cell => {
                const div = document.createElement('div');
                div.className = 'cell';
                if(cell) {
                    div.className += ' filled';
                    div.style.backgroundColor = cell.color;
                    div.textContent = cell.icon;
                }
                gridEl.appendChild(div);
            });
        });
    }

    /* =========================================
       5. ãƒãƒˆãƒ« & ãƒ‘ã‚ºãƒ«åˆ¤å®šï¼ˆé‡åŠ›ãªã—ï¼‰
       ========================================= */
    function checkLines() {
        let linesCleared = 0;
        let totalDmg = 0;
        let totalHeal = 0;

        // æ¨ª
        for(let r=0; r<ROWS; r++) {
            if(grid[r].every(c => c !== null)) {
                // åŠ¹æœè¨ˆç®—
                grid[r].forEach(c => {
                    if(c.type === 'atk') totalDmg += 2;
                    if(c.type === 'crit') totalDmg += 5;
                    if(c.type === 'heal') totalHeal += 5;
                });
                totalDmg += 10; // ãƒ©ã‚¤ãƒ³åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸
                linesCleared++;
                grid[r].fill(null); // æ¶ˆã™ã ã‘ï¼ˆè©°ã‚ãªã„ï¼‰
            }
        }
        // ç¸¦
        for(let c=0; c<COLS; c++) {
            let col = [];
            for(let r=0; r<ROWS; r++) col.push(grid[r][c]);
            if(col.every(c => c !== null)) {
                col.forEach(c => {
                    if(c.type === 'atk') totalDmg += 2;
                    if(c.type === 'crit') totalDmg += 5;
                    if(c.type === 'heal') totalHeal += 5;
                });
                totalDmg += 10;
                linesCleared++;
                for(let r=0; r<ROWS; r++) grid[r][c] = null;
            }
        }

        if(linesCleared > 0) {
            SFX.attack();
            if(totalHeal > 0) SFX.heal();
            applyBattleEffect(totalDmg, totalHeal);
            renderGrid();
        }
    }

    function applyBattleEffect(dmg, heal) {
        if(dmg > 0) {
            enemyHP -= dmg;
            showPopup(dmg, '#enemy-sprite');
            // ãƒ€ãƒ¡ãƒ¼ã‚¸æ¼”å‡º
            const s = document.getElementById('enemy-sprite');
            s.style.transform = 'translate(5px, -5px) scale(0.9)';
            setTimeout(() => s.style.transform = 'none', 100);
        }
        if(heal > 0) {
            playerHP = Math.min(playerHP + heal, maxHP);
            showPopup("+" + heal, '#player-name', '#2ecc71');
        }
        updateUI();

        if(enemyHP <= 0) {
            setTimeout(() => {
                currentEnemyIdx++;
                loadEnemy(currentEnemyIdx);
            }, 500);
        }
    }

    function enemyTurn() {
        if(enemyHP <= 0) return;
        
        // ã‚·ãƒ³ãƒ—ãƒ«ã«æ¯å›æ®´ã£ã¦ãã‚‹ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ã¯æ•µã«ã‚ˆã‚‹ï¼‰
        const dmg = ENEMIES[currentEnemyIdx].atk;
        playerHP -= dmg;
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¢«å¼¾æ¼”å‡º
        const b = document.getElementById('grid-container');
        b.style.transform = 'translateX(-5px)';
        setTimeout(() => b.style.transform = 'none', 50);
        
        if(playerHP <= 0) {
            playerHP = 0;
            gameEnd(false);
        }
        updateUI();
    }

    function showPopup(text, selector, color='#ffeb3b') {
        const el = document.createElement('div');
        el.className = 'damage-popup';
        el.textContent = text;
        el.style.color = color;
        const target = document.querySelector(selector);
        const rect = target.getBoundingClientRect();
        el.style.left = (rect.left + 20) + 'px';
        el.style.top = rect.top + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 800);
    }

    function updateUI() {
        document.getElementById('player-hp-text').textContent = `${Math.floor(playerHP)}/${maxHP}`;
        document.getElementById('player-hp-bar').style.width = `${(playerHP/maxHP)*100}%`;
        
        const maxE = ENEMIES[currentEnemyIdx] ? ENEMIES[currentEnemyIdx].hp : 1; // 0é™¤ç®—é˜²æ­¢
        const curE = Math.max(0, enemyHP);
        document.getElementById('enemy-hp-text').textContent = `${curE}`;
        document.getElementById('enemy-hp-bar').style.width = `${(curE/maxE)*100}%`;
    }

    function gameEnd(isWin) {
        isGameOver = true;
        overlay.style.display = 'flex';
        const title = document.getElementById('msg-title');
        const text = document.getElementById('msg-text');
        const btn = document.querySelector('#overlay button');

        if(isWin) {
            SFX.win();
            title.textContent = "YOU WIN!";
            title.style.color = "#f1c40f";
            text.innerHTML = "ä¼èª¬ã®ãƒ‰ãƒ©ã‚´ãƒ³ã‚’å€’ã—ãŸï¼<br>ä¸–ç•Œã¯å¹³å’Œã«ãªã£ãŸï¼";
        } else {
            SFX.lose();
            title.textContent = "GAME OVER";
            title.style.color = "#e74c3c";
            text.innerHTML = "å‹‡è€…ã¯å€’ã‚ŒãŸ...<br>å†æŒ‘æˆ¦ã—ã¾ã™ã‹ï¼Ÿ";
        }
        btn.textContent = "RETRY";
    }

</script>
</body>
</html>
