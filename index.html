<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Battle Inventory</title>
    <style>
        body {
            background-color: #202020;
            color: white;
            font-family: 'Verdana', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            touch-action: none;
            overflow: hidden;
        }

        /* --- ãƒãƒˆãƒ«ç”»é¢ --- */
        #battle-area {
            width: 100%;
            height: 180px;
            background: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
            border-bottom: 4px solid #000;
        }

        .status-box {
            text-align: center;
            width: 40%;
        }
        
        .hp-bar {
            width: 100%;
            height: 15px;
            background: #555;
            border: 2px solid #000;
            margin-top: 5px;
            position: relative;
        }
        .hp-fill {
            height: 100%;
            background: #2ecc71;
            width: 100%;
            transition: width 0.3s;
        }
        .enemy-hp { background: #e74c3c; }

        #enemy-sprite {
            font-size: 60px;
            animation: bounce 2s infinite;
        }

        /* --- ã‚°ãƒªãƒƒãƒ‰ --- */
        #grid-container {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 2px;
            background-color: #4a3b32; /* é©ã®ã‚«ãƒãƒ³ã£ã½ã„è‰² */
            padding: 5px;
            border: 4px solid #8d6e63;
            border-radius: 4px;
        }

        .cell {
            width: 45px;
            height: 45px;
            background-color: #3e2723;
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }

        .cell.filled { box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .cell.highlight { background-color: rgba(46, 204, 113, 0.5); }
        .cell.invalid { background-color: rgba(231, 76, 60, 0.5); }

        /* --- ã‚¹ãƒãƒ¼ãƒŠãƒ¼ --- */
        #spawner {
            margin-top: auto;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            height: 100px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .item-preview {
            display: grid;
            gap: 1px;
            cursor: grab;
        }
        
        .item-cell {
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: white;
            border-radius: 2px;
        }

        .dragging {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: scale(1.5);
        }

        /* --- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ --- */
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        #message-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
        }
        #message-title { font-size: 32px; font-weight: bold; margin-bottom: 20px; color: gold; }
        button {
            padding: 15px 30px;
            font-size: 20px;
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="battle-area">
        <div class="status-box">
            <div id="player-name">å‹‡è€… (You)</div>
            <div class="hp-bar"><div id="player-hp-bar" class="hp-fill"></div></div>
            <div id="player-hp-text">100/100</div>
        </div>
        
        <div id="enemy-sprite">ğŸ‘¾</div>

        <div class="status-box">
            <div id="enemy-name">ã‚¹ãƒ©ã‚¤ãƒ  Lv.1</div>
            <div class="hp-bar"><div id="enemy-hp-bar" class="hp-fill enemy-hp"></div></div>
            <div id="enemy-hp-text">50/50</div>
        </div>
    </div>

    <div id="grid-container"></div>

    <div id="spawner"></div>

    <div id="message-overlay">
        <div id="message-title">GAME OVER</div>
        <div id="message-desc" style="color:white; margin-bottom:20px;"></div>
        <button onclick="resetGame()">ã‚‚ã†ä¸€åº¦</button>
    </div>

<script>
    // --- ã‚²ãƒ¼ãƒ è¨­å®š ---
    const COLS = 6;
    const ROWS = 7; // å°‘ã—ç‹­ãã—ã¦é›£æ˜“åº¦UP
    
    // ã‚¢ã‚¤ãƒ†ãƒ å®šç¾©ï¼štype: 'atk' (æ”»æ’ƒ), 'def' (å›å¾©/é˜²å¾¡)
    const ITEMS = [
        { shape: [[1]], type: 'atk', color: '#e74c3c', icon: 'ğŸ' }, // ã‚Šã‚“ã”ï¼ˆå°å›å¾©? ã„ãˆã€æŠ•ã’ã¦æ”»æ’ƒã§ã™ï¼‰
        { shape: [[1],[1]], type: 'atk', color: '#c0392b', icon: 'ğŸ—¡ï¸' }, // å‰£ï¼ˆç¸¦ï¼‰
        { shape: [[1,1]], type: 'atk', color: '#c0392b', icon: 'ğŸ—¡ï¸' }, // å‰£ï¼ˆæ¨ªï¼‰
        { shape: [[1,1],[1,1]], type: 'def', color: '#f1c40f', icon: 'ğŸ›¡ï¸' }, // ç›¾
        { shape: [[1,0],[1,1]], type: 'def', color: '#2980b9', icon: 'ğŸ”®' }, // é­”æ³•
        { shape: [[0,1],[1,1]], type: 'def', color: '#2ecc71', icon: 'ğŸŒ¿' }, // è‰
        { shape: [[1,1,1]], type: 'atk', color: '#8e44ad', icon: 'ğŸ¥–' }, // ãƒ‘ãƒ³ï¼ˆé•·ã„ï¼‰
    ];

    // æ•µãƒ‡ãƒ¼ã‚¿
    const ENEMIES = [
        { name: "ã‚¹ãƒ©ã‚¤ãƒ ", hp: 30, atk: 5, icon: "ğŸ’§" },
        { name: "ã‚´ãƒ–ãƒªãƒ³", hp: 60, atk: 8, icon: "ğŸ‘º" },
        { name: "ã‚ªãƒ¼ã‚¯", hp: 100, atk: 12, icon: "ğŸ·" },
        { name: "ã‚´ãƒ¼ãƒ¬ãƒ ", hp: 150, atk: 15, icon: "ğŸ—¿" },
        { name: "ãƒ‰ãƒ©ã‚´ãƒ³", hp: 300, atk: 25, icon: "ğŸ²" } // Boss
    ];

    // --- å¤‰æ•° ---
    let grid = [];
    let currentEnemyIndex = 0;
    let playerHP = 100;
    let maxPlayerHP = 100;
    let enemyHP = 0;
    let maxEnemyHP = 0;
    
    // DOMè¦ç´ 
    const gridContainer = document.getElementById('grid-container');
    const spawner = document.getElementById('spawner');
    const overlay = document.getElementById('message-overlay');
    
    // --- åˆæœŸåŒ– ---
    function init() {
        grid = Array(ROWS).fill().map(() => Array(COLS).fill(null));
        currentEnemyIndex = 0;
        playerHP = 100;
        spawnEnemy(0);
        updateBattleUI();
        renderGrid();
        spawner.innerHTML = '';
        spawnItem(); spawnItem(); spawnItem();
        overlay.style.display = 'none';
    }

    function spawnEnemy(index) {
        if (index >= ENEMIES.length) {
            gameClear();
            return;
        }
        const data = ENEMIES[index];
        enemyHP = data.hp;
        maxEnemyHP = data.hp;
        document.getElementById('enemy-name').textContent = `${data.name} Lv.${index+1}`;
        document.getElementById('enemy-sprite').textContent = data.icon;
        updateBattleUI();
    }

    // --- ãƒãƒˆãƒ«ãƒ­ã‚¸ãƒƒã‚¯ ---
    function turnProcess(linesCleared, clearedItems) {
        // 1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ”»æ’ƒï¼ˆãƒ©ã‚¤ãƒ³æ¶ˆå»ï¼‰
        let damage = 0;
        let heal = 0;

        // æ¶ˆãˆãŸã‚¢ã‚¤ãƒ†ãƒ ã®ç¨®é¡ã‚’é›†è¨ˆ
        clearedItems.forEach(item => {
            if (item.type === 'atk') damage += 10; // æ”»æ’ƒã‚¢ã‚¤ãƒ†ãƒ 1å€‹ã«ã¤ã10ãƒ€ãƒ¡ãƒ¼ã‚¸
            if (item.type === 'def') heal += 5;    // é˜²å¾¡ã‚¢ã‚¤ãƒ†ãƒ 1å€‹ã«ã¤ã5å›å¾©
        });

        // ãƒ©ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹
        damage += linesCleared * 20; 

        // ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
        if (damage > 0) {
            enemyHP -= damage;
            showDamageEffect(damage, 'enemy');
        }
        if (heal > 0) {
            playerHP = Math.min(playerHP + heal, maxPlayerHP);
        }

        // 2. æ•µã®ç”Ÿå­˜åˆ¤å®š
        if (enemyHP <= 0) {
            enemyHP = 0;
            updateBattleUI();
            setTimeout(() => {
                currentEnemyIndex++;
                spawnEnemy(currentEnemyIndex);
            }, 500);
            return; // æ•µãŒå€’ã‚ŒãŸã‚‰æ”»æ’ƒã—ã¦ã“ãªã„
        }

        // 3. æ•µã®æ”»æ’ƒï¼ˆã‚¢ã‚¤ãƒ†ãƒ ã‚’ç½®ããŸã³ã€ã‹ã¤ãƒ©ã‚¤ãƒ³æ¶ˆã›ãªã‹ã£ãŸã‚‰ç—›ã„ï¼Ÿï¼‰
        // ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œæ¯å›æ”»æ’ƒã—ã¦ãã‚‹ãŒã€ãƒ©ã‚¤ãƒ³æ¶ˆã›ã°è»½æ¸›ã€ãªã©
        // ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œã‚¿ãƒ¼ãƒ³æ¯ã«å›ºå®šãƒ€ãƒ¡ãƒ¼ã‚¸ã€
        let enemyAtk = ENEMIES[currentEnemyIndex].atk;
        if (linesCleared > 0) {
            // ãƒ©ã‚¤ãƒ³ã‚’æ¶ˆã—ãŸã‚¿ãƒ¼ãƒ³ã¯é˜²å¾¡æˆåŠŸã§ãƒ€ãƒ¡ãƒ¼ã‚¸åŠæ¸›ã¨ã‹
            // enemyAtk = 0; // ä»Šå›ã¯ã€Œãƒ©ã‚¤ãƒ³æ¶ˆã›ã°ãƒãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸ã€ã«ã—ã¦ã¿ã‚‹ï¼Ÿ
            // ã„ã‚„ã€ã‚¹ãƒªãƒ«ãŒæ¬²ã—ã„ã®ã§ã€Œæ”»æ’ƒã¯é£Ÿã‚‰ã†ã€
        }
        
        playerHP -= enemyAtk;
        showDamageEffect(enemyAtk, 'player');

        // 4. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç”Ÿå­˜åˆ¤å®š
        if (playerHP <= 0) {
            playerHP = 0;
            gameOver("å‹‡è€…ã¯å€’ã‚ŒãŸ...");
        }

        updateBattleUI();
    }

    function updateBattleUI() {
        const pRate = (playerHP / maxPlayerHP) * 100;
        const eRate = (enemyHP / maxEnemyHP) * 100;
        document.getElementById('player-hp-bar').style.width = `${pRate}%`;
        document.getElementById('enemy-hp-bar').style.width = `${eRate}%`;
        document.getElementById('player-hp-text').textContent = `${playerHP}/${maxPlayerHP}`;
        document.getElementById('enemy-hp-text').textContent = `${Math.max(0, enemyHP)}/${maxEnemyHP}`;
    }

    function showDamageEffect(val, target) {
        // ç°¡æ˜“æ¼”å‡ºï¼ˆæœ¬æ¥ã¯ç”»é¢ä¸Šã«æ•°å­—ã‚’æµ®ã‹ã›ã‚‹ï¼‰
        console.log(`${target} took ${val} damage!`);
        const el = target === 'enemy' ? document.getElementById('enemy-sprite') : document.getElementById('grid-container');
        el.style.transform = 'translateX(5px)';
        setTimeout(() => el.style.transform = 'translateX(-5px)', 50);
        setTimeout(() => el.style.transform = 'none', 100);
    }

    // --- ã‚²ãƒ¼ãƒ é€²è¡Œ ---
    function gameClear() {
        document.getElementById('message-title').textContent = "YOU WIN!";
        document.getElementById('message-title').style.color = "#2ecc71";
        document.getElementById('message-desc').textContent = "ã™ã¹ã¦ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å€’ã—ãŸï¼";
        overlay.style.display = 'flex';
    }

    function gameOver(reason) {
        document.getElementById('message-title').textContent = "GAME OVER";
        document.getElementById('message-title').style.color = "#e74c3c";
        document.getElementById('message-desc').textContent = reason;
        overlay.style.display = 'flex';
    }
    
    function resetGame() {
        init();
    }

    // --- ä»¥ä¸‹ã€ãƒ‘ã‚ºãƒ«ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå‰å›ã‹ã‚‰å¤‰æ›´ã‚ã‚Šï¼‰ ---
    
    function renderGrid() {
        gridContainer.innerHTML = '';
        grid.forEach((row, y) => {
            row.forEach((cell, x) => {
                const div = document.createElement('div');
                div.classList.add('cell');
                if (cell) {
                    div.classList.add('filled');
                    div.style.backgroundColor = cell.color;
                    div.textContent = cell.icon;
                }
                gridContainer.appendChild(div);
            });
        });
    }

    function spawnItem() {
        if (spawner.children.length >= 3) return;
        const type = ITEMS[Math.floor(Math.random() * ITEMS.length)];
        const el = document.createElement('div');
        el.classList.add('item-preview');
        el.style.gridTemplateColumns = `repeat(${type.shape[0].length}, 1fr)`;
        
        type.shape.forEach(row => {
            row.forEach(cell => {
                const cellDiv = document.createElement('div');
                cellDiv.classList.add('item-cell');
                if (cell) {
                    cellDiv.style.backgroundColor = type.color;
                    cellDiv.textContent = type.icon;
                } else {
                    cellDiv.style.opacity = 0;
                }
                el.appendChild(cellDiv);
            });
        });
        addDragLogic(el, type);
        spawner.appendChild(el);
    }

    function addDragLogic(element, itemData) {
        let isDragging = false;
        let clone = null;

        const startDrag = (e) => {
            e.preventDefault();
            isDragging = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            clone = element.cloneNode(true);
            clone.classList.add('dragging');
            clone.style.width = element.offsetWidth + 'px';
            clone.style.height = element.offsetHeight + 'px';
            document.body.appendChild(clone);
            moveAt(clientX, clientY);
            element.style.opacity = '0.3';
        };

        const moveAt = (x, y) => {
            if(!clone) return;
            clone.style.left = x - clone.offsetWidth / 2 + 'px';
            clone.style.top = y - clone.offsetHeight / 2 - 50 + 'px'; 
            highlightGrid(x, y - 50, itemData.shape);
        };

        const onMove = (e) => {
            if (!isDragging) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            moveAt(clientX, clientY);
        };

        const endDrag = (e) => {
            if (!isDragging) return;
            isDragging = false;
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

            const dropSuccess = tryPlaceItem(clientX, clientY - 50, itemData);

            if (dropSuccess) {
                element.remove();
                spawnItem();
                // ãƒ©ã‚¤ãƒ³åˆ¤å®š & ã‚¿ãƒ¼ãƒ³å‡¦ç†
                checkLinesAndTurn();
            } else {
                element.style.opacity = '1';
            }
            if(clone) clone.remove();
            clearHighlight();
        };

        element.addEventListener('mousedown', startDrag);
        element.addEventListener('touchstart', startDrag, {passive: false});
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, {passive: false});
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
    }

    function getGridPos(x, y) {
        const rect = gridContainer.getBoundingClientRect();
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return null;
        const cellSize = rect.width / COLS;
        const col = Math.floor((x - rect.left) / cellSize);
        const row = Math.floor((y - rect.top) / cellSize);
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) return { c: col, r: row };
        return null;
    }

    function tryPlaceItem(screenX, screenY, itemData) {
        const pos = getGridPos(screenX, screenY);
        if (!pos) return false;
        const startC = pos.c - Math.floor(itemData.shape[0].length / 2); 
        const startR = pos.r - Math.floor(itemData.shape.length / 2);

        // ãƒã‚§ãƒƒã‚¯
        for (let r = 0; r < itemData.shape.length; r++) {
            for (let c = 0; c < itemData.shape[r].length; c++) {
                if (itemData.shape[r][c] === 1) {
                    const targetC = startC + c;
                    const targetR = startR + r;
                    if (targetC < 0 || targetC >= COLS || targetR < 0 || targetR >= ROWS || grid[targetR][targetC]) {
                        return false;
                    }
                }
            }
        }
        // é…ç½®
        for (let r = 0; r < itemData.shape.length; r++) {
            for (let c = 0; c < itemData.shape[r].length; c++) {
                if (itemData.shape[r][c] === 1) {
                    // ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’ã‚°ãƒªãƒƒãƒ‰ã«ä¿å­˜
                    grid[startR + r][startC + c] = { 
                        color: itemData.color, 
                        icon: itemData.icon,
                        type: itemData.type // atk or def
                    };
                }
            }
        }
        renderGrid();
        return true;
    }

    function highlightGrid(screenX, screenY, shape) {
        clearHighlight();
        const pos = getGridPos(screenX, screenY);
        if (!pos) return;
        const startC = pos.c - Math.floor(shape[0].length / 2);
        const startR = pos.r - Math.floor(shape.length / 2);
        let isValid = true;
        let cellsToHighlight = [];

        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
                if (shape[r][c] === 1) {
                    const targetC = startC + c;
                    const targetR = startR + r;
                    if (targetC < 0 || targetC >= COLS || targetR < 0 || targetR >= ROWS || grid[targetR][targetC]) {
                        isValid = false;
                    } else {
                        const index = targetR * COLS + targetC;
                        if(gridContainer.children[index]) cellsToHighlight.push(gridContainer.children[index]);
                    }
                }
            }
        }
        cellsToHighlight.forEach(el => el.classList.add(isValid ? 'highlight' : 'invalid'));
    }

    function clearHighlight() {
        document.querySelectorAll('.cell').forEach(c => {
            c.classList.remove('highlight');
            c.classList.remove('invalid');
        });
    }

    function checkLinesAndTurn() {
        let linesCleared = 0;
        let clearedItems = []; // æ¶ˆãˆãŸã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆ

        // æ¨ªä¸€åˆ—
        for (let r = ROWS - 1; r >= 0; r--) {
            if (grid[r].every(cell => cell !== null)) {
                // æ¶ˆãˆã‚‹è¡Œã®ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’ä¿å­˜
                grid[r].forEach(cell => clearedItems.push(cell));
                
                grid.splice(r, 1);
                grid.unshift(Array(COLS).fill(null));
                linesCleared++;
                r++;
            }
        }
        // ç¸¦ä¸€åˆ—
        for (let c = 0; c < COLS; c++) {
            let isColFull = true;
            for (let r = 0; r < ROWS; r++) if (!grid[r][c]) isColFull = false;
            if (isColFull) {
                for (let r = 0; r < ROWS; r++) {
                    clearedItems.push(grid[r][c]);
                    grid[r][c] = null;
                }
                linesCleared++;
            }
        }
        
        renderGrid();

        // ãƒãƒˆãƒ«å‡¦ç†ã¸
        turnProcess(linesCleared, clearedItems);

        // æ•—åŒ—æ¡ä»¶ãƒã‚§ãƒƒã‚¯ï¼ˆã‚«ãƒãƒ³ãŒè©°ã¾ã£ã¦ãªã„ã‹ï¼Ÿï¼‰
        // â€»ç°¡æ˜“çš„ã«ã€3ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ å€™è£œãŒã©ã‚Œã‚‚ç½®ã‘ãªã‹ã£ãŸã‚‰è©°ã¿ã¨ã™ã‚‹åˆ¤å®šã‚’å…¥ã‚Œã‚‹ã¨ã‚ˆã‚Šè¦ªåˆ‡
        // ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œç½®ãå ´æ‰€ãŒãªã„ã€ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆ¤æ–­ã«å§”ã­ã€HP0ã‚’ãƒ¡ã‚¤ãƒ³ã®æ•—åŒ—ã¨ã™ã‚‹
        // ãŸã ã—ã€spawnerãŒåŸ‹ã¾ã£ã¦ã„ã¦ç½®ã‘ãªã„ã¨é€²è¡Œä¸å¯ã«ãªã‚‹ã®ã§ã€
        // æœ¬æ¥ã¯ `checkGameOver` ã§ã€Œå…¨ã‚¢ã‚¤ãƒ†ãƒ é…ç½®ä¸å¯ã€ã‚’åˆ¤å®šã™ã¹ãã€‚
        // ã“ã“ã§ã¯ã€ŒHPã§ã®æ­»äº¡ã€ã‚’å„ªå…ˆå®Ÿè£…ã€‚
    }

    init();
</script>
</body>
</html>
